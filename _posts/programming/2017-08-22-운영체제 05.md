---
layout: post
title: 운영체제 05
excerpt: "운영체제 5장 CPU 스케줄링"
description: ""
categories: programming
tags: [운영체제]
author: epi4
comments: true
share: true
---
'Operating System Concepts 8th'를 정리한 글이다.

#### 5.1 기본 개념
단일처리기 시스템에서는 한 순간에 오직 하나의 프로세스만이 실행된다. 나머지 프로세스는 CPU가 자유 상태가 되어 기다려야 한다.

다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 데 있다.

프로세스는 어떤 I/O 요청이 완료되기를 기다려야만 할 때까지 실행된다. 이렇게 되면 단순한 컴퓨터 시스템에서는 CPU가 놀고 있는데 이는 비효율적이다.

다수의 프로세스들을 메모리 내에 유지하였다가 어떤 프로세스가 대기해야 할 경우 운영체제는 CPU를 그 프로세스에게서 회수하여 다른 프로세스에게 할당한다. 이런 패턴은 계속된다.

중요한 컴퓨터 자원인 CPU의 스케줄링은 운영체제 설계의 핵심이 된다.

##### 5.1.1 CPU-입출력 버스트 사이클(CPU-I/O Burst Cycle)
프로세스 실행은 CPU 실행과 입출력 대기의 사이클로 구성된다. 프로세스들은 이들 두 상태 사이를 교대로 반복한다. 프로세스 실행은 CPU 버스트로 시작된다. 뒤이어 입출력 버스트가 발생하고 또 다른 CPU 버스트가 버스트가 발생한다. 이게 반복되다가 마지막 CPU 버스트는 실행을 종료하기 위한 시스템 요청과 함께 끝난다.
<figure>
<img src="/images/OS/OS_5_1.png" alt="image">
	<figcaption>CPU와 입출력 버스트(burst)의 교차</figcaption>
</figure>

##### 5.1.2 CPU 스케줄러(CPU Scheduler)
CPU가 유휴 상태가 될 때 운영체제는 준비완료 큐에 있는 프로세스들 중에 실행될 프로세스를 선택한다. 선택 절차는 단기 스케줄러에 의해 실행된다.

준비완료 큐는 반드시 선입 선출(FIFO) 방식의 큐가 아니어도 되는 것에 유의한다.

##### 5.1.3 선점 스케줄링(Preemptive Scheduling)
CPU 스케줄링은 다음의 네 가지 상황 아에서 발생할 수 잇다.

1. 한 프로세스가 실행 상태에서 대기 상태로 전환될 때
2. 프로세스가 실행 상태에서 준비완료 상태로 전환될 때
3. 프로세스가 대기 상태에서 준비완료 상태로 전환될 때
4. 프로세스가 종료할 때

상황 1과 4에선 선택의 여지가 없다. 준비완료 큐에 프로세스가 있을 경우 반드시 선택되어야 한다. 그러나 상황 2와 3은 선택의 여지가 있다.

상황 1과 4에서만 스케줄링이 발생할 경우 비선점, 협조적 스케줄링이라 한다. 그렇지 않을 경우엔 선점이라 한다.

비선점 스케줄링 하에서는 CPU가 프로세스에 할당되면 이 프로세스가 종료하거나 대기 상태로 전환해서 CPU를 방출할 때까지 CPU를 점유한다.

Window 3.1 기준으로 이전에는 비선점 스케줄링을 사용하다 이후에는 선점 스케줄링을 사용해 오고 있다.

선점 스케줄링은 공유 자료를 접근하는 경우 비용을 유발한다. 한 프로세스가 자료를 갱신하는 동안 선점되어 두 번째 프로세스가 실행 하여 자료를 읽으려고 하면 문제가 생긴다. 이를 조정할 메커니즘이 필요하다. 이는 6장에서 논의된다.

인터럽트는 어느 시점에서건 일어날 수 있고, 커널에 의해 항상 무시될 수 없기에 인터럽트에 의해 영향 받는 코드 부분은 반드시 동시 사용으로부터 보호되어야 한다.

선점의 의미는 운영체제 입장에서 CPU 자원을 선점했기에 CPU 자원을 다른 프로세스에게 줄 수 있을 경우가 선점형이라 기억하면 된다. 비선점은 운영체제가 선점하지 않기에 프로세스가 CPU를 방출할 때까지 기다려야만 한다.

##### 5.1.4 디스패처(Dispatcher)
디스패처는 CPU의 제어를 단기 스케줄러가 선택한 프로세스에게 주는 모듈이며 다음과 같은 작업을 포함한다.

- 문맥을 교환하는 일
- 사용자 모드로 전환하는 일
- 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동(jump)하는 일

디스패처는 모든 프로세스의 문맥 교환 시 호출되므로 가급적 빨라야 한다. 디스패처가 하나의 프로세스를 중단시키고 다른 프로세스를 실행시킬 때까지 소요되는 시간을 디스패치 지연(dispatch latency)라고 한다.

#### 5.2 스케줄링 기준(Scheduling Criteria)
CPU 스케줄링 알고리즘을 비교하기 위한 여러 기준이 있고 사용 되는 기준은 다음과 같다.

- CPU 이용률 : 가능한 CPU를 최대한 바쁘게 유지하기를 원한다.
- 처리량 : 처리량은 단위 시간당 완료된 프로세스의 개수이다. 긴 프로세스인 경우 이 처리량은 시간당 한 개가 될 수 있지만 짧을 경우 초당 10개가 될 수도 있다.
- 총처리 시간 : 특정 프로세스 입장에서 보면 중요 기준은 프로세스를 실행하는데 소요된 시간이다. 프로세스의 제출 시간, 완료 시간의 간격을 합쳐서 총처리 시간이라 한다.
- 대기 시간 : 프로세스가 준비완료 큐에서 대기하면서 보낸 시간의 합이다.
- 응답 시간 : 대화식 시스템에서는 총처리 시간은 최선의 기준이 아닐 수 있다. 응답 시간은 응답이 시작되는 데까지 걸리는 시간이지, 응답을 출력하는 데 걸리는 시간은 아니다.

CPU 이용률과 처리량을 최대화하고 총처리 시간, 대기 시간, 응답 시간을 최소화는 것이 바람직하다. 대부분 평균 측정 시간을 최적화 한다. 어떤 경우에는 평균보다 최소값 또는 최대값을 최적화 한다. 모두가 좋은 서비스를 얻게 보장하기 위해 최대 응답 시간을 최소화하려 할 수도 있다.

#### 5.3 스케줄링 알고리즘(Scheduling Algorithms)
CPU 스케줄링은 준비완료 큐에 있는 어느 프로세스에게 CPU를 할당할 것인지를 결정하는 문제를 다룬다.

##### 5.3.1 선입 선처리 스케줄링(First-Come, First-Served Scheduling)
가장 간단한 CPU 스케줄링 알고리즘은 선입 선처리(FCFS) 스케줄링 알고리즘이다. 이 방법에서는 CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다. 이 정책은 선입선출(FIFO) 큐로 쉽게 관리할 수 있다.

이 정책의 단점은 빨리 끝날 수 있는 프로세스가 오래 걸리는 프로세스로 인해 평균 대기시간이 크게 늘어날 수 있다. 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 호위 효과(convoy effect)라고 한다.

이 선입 선처리 스케줄링은 비선점형이다.

##### 5.3.2 최단 작업 우선 스케줄링(Shortest-Job-First Scheduling)
이 알고리즘은 각 프로세스에 다음 CPU 버스트 길이를 연관시킨다. CPU가 이용 가능해지면 다음 CPU 버스트가 가장 작은 프로세스에게 할당한다. 두 프로세스의 다음 CPU 버스트가 같다면 순위를 정하기 위해 선입 선처리 스케줄링을 적용한다.

SJF 알고리즘의 실제적인 어려움은 다음 CPU 요청의 길이를 파악하는 것이다. 일괄처리 시스템에서 장기 스케줄링의 경우 사용자가 명시해둔 프로세스 시간제한 길이를 이용할 수 있다. SJF 스케줄링은 장기 스케줄링에서 자주 사용된다.

단기 스케줄링에서는 다음 CPU 버스트의 길이를 알 수 있는 방법이 없기에 구현할 수 없다.

SJF 알고리즘은 선점형이거나 또는 비선점형일 수 있다. 선점형 SJF 알고리즘은 현재 실행하는 프로세스를 선점하고 비선점형 SJF 알고리즘은 현재 실행하고 있는 프로세스가 자신의 CPU 버스트를 끝내도록 허용한다.

##### 5.3.3 우선순위 스케줄링(Priority Scheduling)
CPU는 가장 높은 우선순위를 가진 프로세스에게 할당된다. 우선순위가 같은 프로세스들은 선입 선처리(FCFS) 순서로 스케줄된다.

우선순위는 내무적 또는 외부적으로 정의될 수 있다. 내부적으로 정의된 우선순위는 어떤 측정 가능한 양들을 사용한다. 시간제한, 메모리 요구, 열린 파일의 수 등이다. 외부적 우선순위는 프로세스의 중요성, 컴퓨터 사용을 위해 지불되는 비용의 타입과 양, 그 작업을 후원하는 부서 등 운영체제 외부적 기준에 의해 결정된다.

우선순위 스케줄링은 선점형이거나 또는 비선점형이 될 수 있다. 선점형 우선순위 스케줄링은 새로 도착한 프로세스의 우선순위가 높으면 CPU를 선점한다. 비선점형 우선순위는 단순히 준비완료 큐의 머리 부분에 새로운 프로세스를 넣는다.

우선순위 스케줄링의 주요 문제는 무기한 봉쇄 또는 기아 상태다.

실행 준비는 되어 있으나 CPU를 사용하지 못 하는 프로세스는 CPU를 기다리며 봉쇄된 것으로 간주될 수 있다. 부하가 과중한 컴퓨터 시스템에서 높은 우선순위의 프로세스들이 꾸준히 들어오면 우선순위가 낮은 프로세스는 끝까지 실행되지 못 할 수도 있다.

낮은 우선순위의 프로세스들이 무기한 봉쇄되는 문제에 대한 한 가지 해결 방안은 노화(aging)이다. 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다. 그러면 시간이 오래 지난 프로세스는 초기에 우선순위가 낮았더라도 언젠가 실행이 가능해질 것이다.

##### 5.3.4 라운드 로빈 스케줄링(Round-Robin Scheduling)
라운드 로빈(RR) 스케줄링은 특별히 시분할 시스템을 위해 설계되었다. 선입 선처리 스케줄링과 유사하지만 시스템이 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가된다. 시간 할당량이라 하는 작은 단위의 시간을 정의하는데 일반적으로 10에서 100밀리초이다. CPU 스케줄러는 준비완료 큐를 돌면서 한 프로세스에게 한 번의 시간 할당량 동안 CPU를 할당한다.

CPU 스케줄러는 준비완료 큐에서 첫 번째 프로세스를 선택해 한 번의 시간 할당량 이후에 인터럽트를 걸도록 타이머를 설정한 후, 프로세스를 디스패치(dispatch)한다. 이러면 두 가지 중 하나가 발생한다.

첫 번째는 프로세스의 CPU 버스트가 한 번의 시간 할당량보다 작을 수 있다. 이 경우에 프로세스 자신이 CPU를 자발적으로 방출한다. 스케줄러는 그 후 준비완료 큐에 있는 프로세스로 진행한다.

두 번째는 실행 중인 프로세스의 CPU 버스트가 한 번의 시간 할당량보다 긴 경우인데 타이머가 만료되면 운영체제에게 인터럽트를 발생시킬 것이다. 문맥 교환이 일어나고, 실행하던 프로세스는 준비완료 큐의 꼬리에 넣어진다. 그 후 CPU 스케줄러는 준비완료 큐의 다음 프로세스를 선택할 것이다.

RR 알고리즘의 성능은 시간 할당량의 크기에 매우 많은 영향을 받는다. 극단적인 경우, 시간 할당량이 매우 크면, RR 정책은 선입 선처리 정책과 같다. 이와 반대로 시간 할당량이 매우 적다면 라운드 로빈 방식은 계속되는 문맥 교환으로 인해 효율이 저하된다.

그러므로 문맥 교환 시간을 고려하여 시간 할당량은 길게 주어져야 한다. 실제로 대부분의 현대 운영체제들은 10~100밀리초 범위의 시간 할당량을 가지고 있다. 문맥 교환을 하는데 걸리는 시간은 보통 10마이크로초 미만이다. 따라서 문맥 교환 시간은 작은 부분을 차지한다.

##### 5.3.5 다단계 큐 스케줄링(Multilevel Queue Scheduling)
프로세스들이 쉽게 상이한 그룹으로 분류될 수 있는 상황을 위해 또 다른 클래스의 스케줄링 알고리즘이 고안되었다. 예를 들면 포그라운드 프로세스들과 백그라운드 프로세스들로 구분한다. 이들 두 유형의 프로세스는 응답 시간에 대한 요구사항이 다르기 때문에 스케줄링 요구 또한 다르다.

다단계 큐 스케줄링 알고리즘은 준비완료 큐를 다수의 별도의 큐로 분류한다. 일반적으로 프로세스들은 메모리 크기, 프로세스의 우선순위 혹은 프로세스 유형과 같은 프로세스의 특성에 따라 한 개의 큐에 영구적으로 할당된다.
<figure>
<img src="/images/OS/OS_5_6.png" alt="image">
	<figcaption>단일 및 다중 스레드 프로세스</figcaption>
</figure>

각 큐는 자신의 스케줄링 알고리즘을 갖고 있다. 예를 들어, 포그라운드 큐는 RR 알고리즘에 의해 스케줄링 되지만 백그랑누드 큐는 선입 선처리 알고리즘에 의해 스케줄될 수 있다.

큐와 큐 사이에 스케줄링도 반드시 있어야 하는데 일반적으로 고정 우선순위의 선점형 스케줄링으로 구현된다.

다른 가능성은 큐들 사이에 시간을 나누어 사용하는 것이다. 각 큐는 CPU 시간의 일정량을 받는다. 예를 들면 포그라운드 큐는 CPU 시간의 80%를 받아서 RR 스케줄링을 하고 백그라운드 큐는 20%를 할당받아서 선입 선처리 방식으로 스케줄할 수 있다.

##### 5.3.6 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)
다단계 큐 스케줄링 알고리즘에서는 일반적으로 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당된다. 예를 들어 포그라운드와 백그라운드 프로세스를 위한 별도의 큐가 있을 경우 프로세스들은 한 큐에서 다른 큐로 이동하지 않는다. 왜냐하면 프로세스들이 포그라운드와 백그라운드의 특성을 바꾸지 않기 때문이다. 이런 방식은 스케줄링 오버헤드가 적은 장점이 있으나 융통성이 적다.

대조적으로 다단계 피드백 큐 스케줄링 알고리즘에서는 프로세스가 큐 사이를 이동하는 것을 허용한다. 어떤 프로세스가 CPU 시간을 너무 많이 사용하고 있으면 낮은 우선순위의 큐로 이동한다. 마찬가지로 낮은 우선순위의 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위의 큐로 이동할 수 있다. 이런 노화(aging) 형태는 기아 상태를 예방한다.

예를 들어 0,1,2 세 개의 큐가 있고 스케줄러는 0의 모든 프로세스를 실행한다. 0의 큐가 비어있다면 1의 큐를 실행한다. 0과 1이 모두 비어있다면 2를 실행한다.

준비 완료 큐로 들어오는 프로세스는 0에 넣어진다. 이때 8밀리의 시간 안에 실행이 종료되지 않는다면 큐 1로 들어간다. 큐 1에서는 16밀리의 시간이 주어지는데 이 안에 완료되지 않는다면 큐 2로 들어간다.

이런 방식으로 실행하면 8밀리 이하인 프로세스에겐 최고의 우선순위가 부여되며 8이상 24이하인 프로세스는 두 번째의 빠른 우선순위가 부여된다.
<figure>
<img src="/images/OS/OS_5_7.png" alt="image">
	<figcaption>다단계 피드백 큐</figcaption>
</figure>

이 알고리즘은 가장 일반적인 CPU 스케줄링 알고리즘이다. 가장 복잡한 알고리즘이기도 하다.

#### 5.4 스레드 스케줄링(Thread Scheduling)
4장에서 프로세스 모델에 스레드를 도입하며 사용자 수준과 커널 수준 스레드를 구분하였다. 이 둘을 지원하는 운영체제에서 스케줄되는 대상은 프로세스가 아니라 커널 수준 스레드이다.

사용자 수준 스레드는 스레드 라이브러리에 의해 관리되고 커널은 그들의 존재를 알지 못 한다.

##### 5.4.1 경쟁 범위(Contention Scope)
사용자 수준과 커널 수준 스레드의 차이 중 하나는 그들이 어떻게 스케줄되느냐에 있다. 다-대-일과 다-대-다 모델을 구현하는 시스템에서는 스레드 라이브러리는 사용자 수준 스레드를 가용한 LWP(lightweight process-경량 프로세스) 상에서 스케줄한다. 이 구조는 동일한 프로세스에 속한 스레드들 사이에서 CPU를 경쟁하기 때문에 프로세스-경쟁-범위(Process-Contention Scope, PCS)로 알려져 있다.

CPU 상에 어느 커널 스레드를 스케줄할 것인지 결정하기 위해서 커널은 시스템-경쟁 범위(System-Contention Scope, SCS)를 사용한다.

PCS는 우선순위에 따라 행해진다. 스케줄러는 가장 높은 우선순위를 가진 실행 가능한 프로세스를 선택한다. 사용자 수준 스레드의 우선순위는 프로그래머에 의해 지정되고 스레드 라이브러리에 의해 조정되지 않는다.

##### 5.4.2 Pthread 스케줄링
스레드를 생성하면서 PCS 또는 SCS를 지정할 수 있는 POSIX Pthreads API를 강조한다.

#### 5.5 다중처리기 스케줄링(Multiple-Processor Scheduling)
지금까지 눈의는 단일처리기를 가진 시스템에서 CPU를 스케줄 하는 문제에 주안점을 두었다. 만일 여러 개의 CPU가 사용 가능하면 부하 공유가 가능해진다.

##### 5.5.1 다중처리기 스케줄링에 대한 접근 방법(Approaches to Multiple-Processor Scheduling)
다중처리기 시스템의 CPU 스케줄링에 관한 한 가지 해결 방법은 주 서버(master server)라는 하나의 처리기가 모든 스케줄링 결정과 입출력 처리 그리고 다른 시스템의 활동을 처리하게 하는 것이다. 다른 처리기들은 다만 사용자 코드만을 실행한다. 이를 비대칭 다중처리(asymmetric multiprocessing)라 한다.

두 번째 해결 방법은 대칭 다중처리(symmertric multiprocessing, SMP)를 사용하는 것인데 이 방식에서는 각 처리기가 독자적으로 스케줄링한다. 모든 프로세스는 공동의 준비 완료 큐에 있거나 각 처리기마다 가지고 있는 사유의 준비완료 큐에 있게된다.

##### 5.5.2 처리기 친화성(Processor Affinity)
프로세스가 특정 처리기에서 실행 중일 때 캐시 메모리에서 어떤 일이 일어날까? 처리기에 의해 가장 최근에 접근된 데이터가 그 처리기의 캐시를 채우게 된다. 이제 프로세스가 다른 처리기로 이주하면 어떤 일이 일어날까? 첫 번째 처리기의 캐시 메모리 내용은 무효화되고 두 번째 처리기는 다시 채워야 한다. 캐시를 무효화하고 다시 채우는 작업은 비용이 많이 들기에 대부분의 SMP시스템은 한 처리기에서 다른 처리기의 이주를 피하고 대신 같은 처리기에서 프로세스를 실행시키려고 한다. 이 현상을 처리기 친화성(processor affinity)라 하며 프로세스가 현재 실행 중인 처리기에 친화성을 가진다는 것을 의미한다.

운영체제가 동일한 처리기에서 프로세스를 실행시키려고 노력하는 정책을 가지고 있지만 보장하지 않을 때 약한 친화성(soft affinity)을 가진다고 한다.

##### 5.5.3 부하 균등화(load Balancing)
SMP 시스템에서 처리기가 하나 이상이라는 것을 최대한 활용하려면, 부하를 모든 처리기에게 균등하게 배분하는 것이 중요하다. 부하 균등화는 통상 각 처리기마다 자기 자신만의 준비완료 큐를 가지고 있는 시스템에서만 필요한 기능이라는 것을 주의해야 한다.

부하 균등화를 위해서는 push 이주와 pull 이주 방식의 두 가지 일반적인 접근법이 있다. push 이주에서는 특정 태스크가 주기적으로 각 처리기의 부하를 검사하고, 만일 불균등 상태로 밝혀지면 과부하인 처리기에서 쉬고 있거나 덜 바쁜  처리기로 프로세스를 이동시킴으로써 부하를 분배한다. Pull 이주 방식은 쉬고 있는 처리기가 바쁜 처리기를 기다리고 있는 프로세스를 자기 쪽으로 가져올 때 일어난다.

Push와 Pull 이주는 상호 배타적일 필요는 없으며 실제로 종종 병렬적으로 구현된다.

##### 5.5.4 다중코어 프로세서(Multicore Processors)
SMP 시스템은 다수의 물리 처리기를 제공함으로써 다수의 스레드를 동시에 실행시킨다. 그러나 컴퓨터 하드웨어의 최근 경향은 하나의 물리적인 칩 안에 여러 개의 처리기 코어를 장착하는데 이런 구조를 다중코어 프로세스(multicore processor)라 한다. 각 코어는 레지스터 집합을 가지고 있기에 운영체제 입장에서는 별개의 물리 처리기처럼 보이게 된다.

다중코어 프로세서는 스케줄링 문제를 복잡하게 한다. 연구자들은 프로세서가 메모리를 접근할 때 데이터가 가용해지기를 기다리면서 많은 시간을 허비한다는 것을 발견하였는데 이를 메모리 멈춤(memory stall)이라 한다.

##### 5.5.5 가상화와 스케줄링(Virtualization and Scheduling)
하나의 CPU를 가졌더라도 가상화를 지원하는 시스템은 종종 다중처리기 시스템처럼 동작한다. 가상화 소프트웨어는 시스템에서 실행 중인 가상기계 마다 하나 이상의 가상 CPU를 제공하고 물리 CPU들을 가상기계가 사용할 수 있도록 스케줄한다.

#### 5.6 운영체제 사례들
(밑은 다음에 정리한다.)

##### 5.6.1 예 : Solaris 스케줄링

##### 5.6.2 예 : Windows XP 스케줄링

##### 5.6.3 예 : Linux 스케줄링

#### 5.7 알고리즘의 평가

##### 5.7.1 결정론적 모델링(Deterministic Modeling)

##### 5.7.2 큐잉 모델(Queueing Models)

##### 5.7.3 모의실험(Simulation)

##### 5.7.4 구현(Implementation)

#### 5.8 요약
CPU 스케줄링은 준비완료 큐로부터 대기 중인 프로세스를 선택해 CPU를 할당하는 작업이다. CPU는 디스패처에 의해 선택된 프로세스에게 할당된다.

선입 선처리(FCFS) 스케줄링은 단순한 스케줄링 알고리즘이지만, 짧은 프로세스들이 매우 긴 프로세스들이 끝날 때까지 기다려야 하는 경우를 유발시킨다.

최소 작업 우선(SJF) 스케줄링은 최적임이 증명 가능하며, 가장 짧은 대기 시간을 제공한다. 이를 구현하기는 어려운데 다음 CPU 버스트의 길이를 예측하기 어렵기 때문이다. SJF 알고리즘은 일반적인 우선순위 스케줄링 알고리즘의 특별한 경우이다. 우선순위와 SJF 스케줄링은 모두 기아 상태를 겪을 수 있는데 노화(aging)는 기아 상태를 예방하는 기법이다.

라운드 로빈(RR) 스케줄링은 시분할(대화형) 시스템에 더 적합하다. 라운드 로빈 스케줄링은 준비완료 큐에 있는 첫 번째 프로세스에게 q 시간 단위 동안 CPU를 할당한 후 그 시간이 지나면 프로세스는 준비완료 큐의 꼬리로 이동한다. 주요 문제는 시간 할당량을 선택하는 것이다. 시간 할당량이 너무 크면 RR 스케줄링은 선입 선처리 스케줄링으로 격하되고 너무 적으면 문맥 교환 시간의 오버헤드가 지나치게 커진다.

선입 선처리 알고리즘은 비선점, 라운드 로빈 알고리즘은 선점형이다. SJF와 우선순위 알고리즘은 선점형/비선점형 둘 다 가능하다.

다단계 큐 알고리즘은 다양항 클래스의 프로레스들에 대해 상이한 알고리즘을 사용하도록 허용한다. 가장 보편적인 모델은 라운드 로빈 스케줄링을 사용하는 전위 대화형 큐와 선입 선처리 스케줄링을 사용하는 후위 일괄처리 큐이다. 다단계 피드백 큐는 프로세스들을 한 큐에서 다른 큐로 이동하는 것을 허용한다.

스레드를 커널 차원에서 지원하는 운영체제는 프로세스가 아니라 스레드를 스케줄링해야 한다.
